# ğŸš€ ONE-CLICK FASTAPI DEPLOYMENT
# Copy this entire cell to Google Colab and run it!

import os
import subprocess
import sys
import time
import threading
import requests
from datetime import datetime

print("ğŸ¯ ONE-CLICK FASTAPI DEPLOYMENT STARTING...")
print("=" * 60)

# Step 1: Install packages
print("\nğŸ“¦ Installing required packages...")
packages_to_install = ["pyngrok", "fastapi", "uvicorn[standard]", "python-dotenv", "requests", "aiofiles", "fastapi==0.104.1", "uvicorn==0.24.0"]

for package in packages_to_install:
    try:
        subprocess.check_call([sys.executable, "-m", "pip", "install", "-q", package])
        print(f"âœ… Installed: {package}")
    except:
        print(f"âš ï¸ Failed to install: {package}")

print("âœ… Package installation completed!")

# Step 2: Clone repository with enhanced support (Public/Private)
print("\nğŸ“¥ Cloning repository...")
github_url = "https://github.com/sonagara-vashram/test.git"

# Ensure clean directory
if os.path.exists('/content/app'):
    subprocess.run(['rm', '-rf', '/content/app'], check=False)

# Enhanced clone methods supporting both public and private repos
clone_success = False
clone_methods = [
    # Method 1: Standard git clone
    {
        'name': 'Standard Clone',
        'cmd': lambda: subprocess.run(['git', 'clone', github_url, '/content/app'], 
                                    check=True, capture_output=True, text=True, timeout=60)
    },
    # Method 2: Clone with depth 1 (faster for large repos)
    {
        'name': 'Shallow Clone',
        'cmd': lambda: subprocess.run(['git', 'clone', '--depth', '1', github_url, '/content/app'], 
                                    check=True, capture_output=True, text=True, timeout=60)
    },
    # Method 3: Clone with different configs for network issues
    {
        'name': 'Enhanced Clone',
        'cmd': lambda: (
            subprocess.run(['git', 'config', '--global', 'http.postBuffer', '524288000'], check=False),
            subprocess.run(['git', 'config', '--global', 'http.sslverify', 'false'], check=False),
            subprocess.run(['git', 'clone', '--depth', '1', '--single-branch', github_url, '/content/app'], 
                         check=True, capture_output=True, text=True, timeout=90)
        )[-1]
    },
    # Method 4: Alternative clone for private repos
    {
        'name': 'Alternative Clone',
        'cmd': lambda: subprocess.run(['git', 'clone', '--recurse-submodules', '--depth', '1', github_url, '/content/app'], 
                                    check=True, capture_output=True, text=True, timeout=90)
    }
]

for i, method in enumerate(clone_methods, 1):
    try:
        print(f"ğŸ”„ {method['name']} (Attempt {i}/{len(clone_methods)})...")
        result = method['cmd']()
        clone_success = True
        print("âœ… Repository cloned successfully!")
        break
    except subprocess.CalledProcessError as e:
        error_details = e.stderr.strip() if e.stderr else str(e)
        print(f"âš ï¸ {method['name']} failed: {error_details[:100]}")
        
        # Provide specific guidance based on error
        if 'Authentication failed' in error_details:
            print("ğŸ”‘ Note: Private repository detected - ensure access permissions")
        elif 'Repository not found' in error_details:
            print("ğŸ” Note: Check repository URL and accessibility")
        elif 'timeout' in error_details.lower():
            print("â° Note: Network timeout - retrying with different method")
            
        if i == len(clone_methods):
            print("\nâŒ All clone attempts exhausted. Troubleshooting:")
            print("\nğŸ”§ **Common Solutions:**")
            print("1. âœ… **Check Repository URL** - Ensure it's correct and accessible")
            print("2. âœ… **Repository Access** - Works with both Public and Private repos")
            print("3. âœ… **Network Issues** - Try running the cell again")
            print("4. âœ… **GitHub Status** - Check if GitHub is accessible")
            print("5. âœ… **Repository Exists** - Verify the repository exists")
            print(f"\nğŸ”— **Repository URL:** {github_url}")
            print("\nâš¡ **Quick Fix:** Verify the repository URL and try again!")
            
            # Don't raise exception immediately, try alternative approach
            print("\nğŸ”„ Attempting alternative download method...")
            try:
                # Try downloading as ZIP if git clone fails
                import urllib.request
                import zipfile
                
                if github_url.endswith('.git'):
                    zip_url = github_url[:-4] + '/archive/main.zip'
                else:
                    zip_url = github_url + '/archive/main.zip'
                
                print(f"ğŸ“¦ Trying ZIP download: {zip_url}")
                urllib.request.urlretrieve(zip_url, '/tmp/repo.zip')
                
                with zipfile.ZipFile('/tmp/repo.zip', 'r') as zip_ref:
                    zip_ref.extractall('/content/')
                
                # Find the extracted folder and rename it
                import glob
                extracted_folders = glob.glob('/content/*-main') + glob.glob('/content/*-master')
                if extracted_folders:
                    extracted_folder = extracted_folders[0]
                    subprocess.run(['mv', extracted_folder, '/content/app'], check=True)
                    clone_success = True
                    print("âœ… Repository downloaded successfully via ZIP!")
                    break
                    
            except Exception as zip_error:
                print(f"âŒ ZIP download also failed: {zip_error}")
                raise Exception(f"Failed to clone/download repository after all attempts. Last error: {error_details}")
        else:
            time.sleep(2)  # Wait before retry

if clone_success:
    os.chdir('/content/app')
    
    # Show repository contents
    print("\nğŸ“‚ Repository contents:")
    try:
        result = subprocess.run(['ls', '-la'], capture_output=True, text=True, check=True)
        print(result.stdout)
    except:
        # Fallback to Python directory listing
        import glob
        files = glob.glob('*') + glob.glob('.*')
        for f in sorted(files):
            print(f"  {f}")
    
    # Install project requirements if exists
    if os.path.exists('requirements.txt'):
        print("\nğŸ“‹ Installing project requirements...")
        try:
            result = subprocess.run([sys.executable, "-m", "pip", "install", "-q", "-r", "requirements.txt"], 
                                  capture_output=True, text=True, check=True)
            print("âœ… Project requirements installed!")
        except subprocess.CalledProcessError as req_error:
            print(f"âš ï¸ Warning: Some requirements failed to install: {req_error.stderr[:200]}")
            print("ğŸ”„ Continuing with available packages...")
    else:
        print("\nğŸ“‹ No requirements.txt found - using base packages only")

# Step 3: Set environment variables
print("\nğŸ” Setting up environment variables...")
# ğŸ” Setting up environment variables\nimport os\n\nos.environ["SECRET_KEY"] = "your_secret_key"\n\nprint('âœ… Set 1 environment variables')\nprint('ğŸ” Environment variables configured:')\nenv_vars_list = ['SECRET_KEY']\nfor key in env_vars_list:\n    print(f'  âœ“ {key}')

print("âœ… Environment variables setup completed!")

# Step 4: Import and start FastAPI app
print("\nğŸ” Loading FastAPI application...")
app_file = "main.py"
app_variable = "app"

try:
    import importlib.util
    
    spec = importlib.util.spec_from_file_location('main_app', app_file)
    app_module = importlib.util.module_from_spec(spec)
    spec.loader.exec_module(app_module)
    
    if hasattr(app_module, app_variable):
        fastapi_app = getattr(app_module, app_variable)
        print(f"âœ… Found FastAPI app: {app_variable}")
        print(f"ğŸ“Š App type: {type(fastapi_app)}")
    else:
        print(f"âŒ App variable '{app_variable}' not found in {app_file}")
        print("Available variables:")
        for attr in dir(app_module):
            if not attr.startswith('_'):
                print(f"  - {attr}: {type(getattr(app_module, attr))}")
        raise Exception("App variable not found")
        
except Exception as e:
    print(f"âŒ Error loading FastAPI app: {e}")
    raise

# Step 5: Start FastAPI server
print("\nğŸš€ Starting FastAPI server...")

import uvicorn

def start_server():
    uvicorn.run(fastapi_app, host='0.0.0.0', port=8000, log_level='warning')

server_thread = threading.Thread(target=start_server, daemon=True)
server_thread.start()

# Wait for server to start
print("â³ Waiting for server to start...")
time.sleep(8)
print("âœ… FastAPI server started on port 8000!")

# Step 6: Create ngrok tunnel
print("\nğŸŒ Creating public URL with ngrok...")

try:
    from pyngrok import ngrok
    from google.colab import userdata
    
    # Try to get auth token from Colab secrets
    try:
        ngrok_auth_token = userdata.get('NGROK_AUTH_TOKEN')
        ngrok.set_auth_token(ngrok_auth_token)
        print("âœ… Using ngrok auth token from Colab secrets!")
    except:
        # Use default auth token if no secret found
        default_token = "30oMBfbIEdvTYekQdAcxmWkzsUr_6ufCyH4WdqtHty73j44y4"
        try:
            ngrok.set_auth_token(default_token)
            print("âœ… Using default ngrok auth token!")
        except:
            print("âš ï¸ No NGROK_AUTH_TOKEN in Colab secrets - using free tier")
            print("ğŸ’¡ For unlimited sessions: Add NGROK_AUTH_TOKEN to Colab secrets")
    
    # Create tunnel
    public_tunnel = ngrok.connect(8000)
    public_url = public_tunnel.public_url
    
    print("\nğŸ‰ DEPLOYMENT SUCCESSFUL! ğŸ‰")
    print("=" * 60)
    print(f"ğŸ”— PUBLIC API URL: {public_url}")
    print(f"ğŸ“š Swagger UI: {public_url}/docs")
    print(f"ğŸ“‹ ReDoc: {public_url}/redoc")
    print("=" * 60)
    
    # Test the API
    print("\nğŸ§ª Testing API...")
    try:
        response = requests.get(f"{public_url}/", timeout=10)
        if response.status_code == 200:
            print("âœ… API is responding correctly!")
            print(f"ğŸ“Š Response preview: {response.text[:100]}...")
        else:
            print(f"âš ï¸ API returned status: {response.status_code}")
    except Exception as test_error:
        print(f"âš ï¸ API test failed: {test_error}")
    
    print("\nğŸ¯ YOUR FASTAPI BACKEND IS NOW LIVE!")
    print("ğŸ’¡ Copy the PUBLIC API URL above for your frontend")
    print("âš ï¸ Keep this notebook running to maintain the API")
    
    # Store URL globally
    globals()['PUBLIC_API_URL'] = public_url
    
    print("\nğŸ“± QUICK LINKS:")
    print(f"ğŸ  Homepage: {public_url}/")
    print(f"ğŸ“š API Docs: {public_url}/docs")
    print(f"ğŸ“‹ ReDoc: {public_url}/redoc")
    
    print("\nâœ¨ DEPLOYMENT COMPLETED SUCCESSFULLY! âœ¨")
    
except Exception as e:
    print(f"âŒ Failed to create ngrok tunnel: {e}")
    print("\nğŸ”§ Troubleshooting:")
    print("1. Ensure FastAPI server is running")
    print("2. Check if port 8000 is accessible")
    print("3. Try running this cell again")
    print("4. For unlimited ngrok: Add NGROK_AUTH_TOKEN to Colab secrets")
    raise

# Optional: Simple monitoring function
def monitor_api():
    """Simple API monitoring function"""
    if 'PUBLIC_API_URL' in globals():
        api_url = globals()['PUBLIC_API_URL']
        print(f"\nğŸ”„ Monitoring API: {api_url}")
        print("Run this function to check API health:")
        print("monitor_api()")
        
        try:
            response = requests.get(f"{api_url}/", timeout=5)
            timestamp = datetime.now().strftime('%H:%M:%S')
            if response.status_code == 200:
                print(f"âœ… {timestamp} - API healthy ({response.status_code})")
            else:
                print(f"âš ï¸ {timestamp} - API status: {response.status_code}")
        except Exception as e:
            print(f"âŒ {timestamp} - API check failed: {e}")
    else:
        print("âŒ No API URL found")

print("\nğŸ¯ To monitor your API, run: monitor_api()")
